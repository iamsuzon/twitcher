import { SequentialAuthTokenRequestExecuter } from './token-request';
import { AblyChannel } from '../ably-channel';
import { AblyConnector } from '../../connector/ably-connector';
import { AuthOptions, ChannelStateChange, ClientOptions } from '../../../typings/ably';
export declare class AblyAuth {
    authEndpoint: string;
    authHeaders: any;
    authRequestExecuter: SequentialAuthTokenRequestExecuter;
    ablyConnector: AblyConnector;
    expiredAuthChannels: Set<string>;
    setExpired: (channelName: string) => Set<string>;
    isExpired: (channelName: string) => boolean;
    removeExpired: (channelName: string) => boolean;
    options: AuthOptions & Pick<ClientOptions, 'echoMessages'>;
    requestToken: (channelName: string, existingToken: string) => Promise<any>;
    constructor(ablyConnector: AblyConnector, options: any);
    ablyClient: () => any;
    existingToken: () => import("ably").Types.TokenDetails;
    getChannel: (name: any) => AblyChannel;
    enableAuthorizeBeforeChannelAttach: () => void;
    allowReconnectOnUserLogin: () => void;
    /**
     * This will be called when (guest)user logs in and new clientId is returned in the jwt token.
     * If client tries to authenticate with new clientId on same connection, ably server returns
     * error and connection goes into failed state.
     * See https://github.com/ably/laravel-broadcaster/issues/45 for more details.
     * There's a separate test case added for user login flow => ably-user-login.test.ts.
     */
    onClientIdChanged: () => void;
    tryAuthorizeOnSameConnection: (authOptions?: AuthOptions, callback?: (error: any, TokenDetails: any) => void) => void;
    onChannelFailed: (echoAblyChannel: AblyChannel) => (stateChange: ChannelStateChange) => void;
    handleChannelAuthError: (echoAblyChannel: AblyChannel) => void;
    setPresenceInfo: (echoAblyChannel: AblyChannel, info: any) => void;
}
