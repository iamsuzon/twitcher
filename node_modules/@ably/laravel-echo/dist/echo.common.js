'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}

/**
 * This class represents a basic channel.
 */
var Channel = /*#__PURE__*/function () {
  function Channel() {
    _classCallCheck(this, Channel);
  }
  _createClass(Channel, [{
    key: "listenForWhisper",
    value:
    /**
     * Listen for a whisper event on the channel instance.
     */
    function listenForWhisper(event, callback) {
      return this.listen('.client-' + event, callback);
    }
    /**
     * Listen for an event on the channel instance.
     */
  }, {
    key: "notification",
    value: function notification(callback) {
      return this.listen('.Illuminate\\Notifications\\Events\\BroadcastNotificationCreated', callback);
    }
    /**
     * Stop listening for a whisper event on the channel instance.
     */
  }, {
    key: "stopListeningForWhisper",
    value: function stopListeningForWhisper(event, callback) {
      return this.stopListening('.client-' + event, callback);
    }
  }]);
  return Channel;
}();

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * Event name formatter
 */
var EventFormatter = /*#__PURE__*/function () {
  /**
   * Create a new class instance.
   */
  function EventFormatter(namespace) {
    _classCallCheck(this, EventFormatter);
    this.namespace = namespace;
    //
  }
  /**
   * Format the given event name.
   */
  _createClass(EventFormatter, [{
    key: "format",
    value: function format(event) {
      if (['.', '\\'].includes(event.charAt(0))) {
        return event.substring(1);
      } else if (this.namespace) {
        event = this.namespace + '.' + event;
      }
      return event.replace(/\./g, '\\');
    }
    /**
     * Set the event namespace.
     */
  }, {
    key: "setNamespace",
    value: function setNamespace(value) {
      this.namespace = value;
    }
  }]);
  return EventFormatter;
}();

/**
 * This class represents an Ably channel.
 */
var AblyChannel = /*#__PURE__*/function (_Channel) {
  _inherits(AblyChannel, _Channel);
  /**
   * Create a new class instance.
   */
  function AblyChannel(ably, name, options) {
    var _this;
    var autoSubscribe = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    _classCallCheck(this, AblyChannel);
    _this = _callSuper(this, AblyChannel);
    _this._alertErrorListeners = function (err) {
      if (err) {
        _this.errorListeners.forEach(function (listener) {
          return listener(err);
        });
      }
    };
    _this.name = name;
    _this.ably = ably;
    _this.options = options;
    _this.eventFormatter = new EventFormatter(_this.options.namespace);
    _this.subscribedListeners = [];
    _this.errorListeners = [];
    _this.channel = ably.channels.get(name);
    _this.callbacks = new Map();
    if (autoSubscribe) {
      _this.subscribe();
    }
    return _this;
  }
  /**
   * Subscribe to an Ably channel.
   */
  _createClass(AblyChannel, [{
    key: "subscribe",
    value: function subscribe() {
      var _this2 = this;
      this.channel.on(function (stateChange) {
        var previous = stateChange.previous,
          current = stateChange.current,
          reason = stateChange.reason;
        if (previous !== 'attached' && current == 'attached') {
          _this2.subscribedListeners.forEach(function (listener) {
            return listener();
          });
        } else if (reason) {
          _this2._alertErrorListeners(stateChange);
        }
      });
      this.channel.attach(this._alertErrorListeners);
    }
    /**
     * Unsubscribe from an Ably channel, unregister all callbacks and finally detach the channel
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      this.channel.unsubscribe();
      this.callbacks.clear();
      this.unregisterError();
      this.unregisterSubscribed();
      this.channel.off();
      this.channel.detach();
    }
    /**
     * Listen for an event on the channel instance.
     */
  }, {
    key: "listen",
    value: function listen(event, callback) {
      this.callbacks.set(callback, function (_a) {
        var data = _a.data,
          metaData = __rest(_a, ["data"]);
        return callback(data, metaData);
      });
      this.channel.subscribe(this.eventFormatter.format(event), this.callbacks.get(callback));
      return this;
    }
    /**
     * Listen for all events on the channel instance.
     */
  }, {
    key: "listenToAll",
    value: function listenToAll(callback) {
      var _this3 = this;
      this.callbacks.set(callback, function (_a) {
        var name = _a.name,
          data = _a.data,
          metaData = __rest(_a, ["name", "data"]);
        var namespace = _this3.options.namespace.replace(/\./g, '\\');
        var formattedEvent = name.startsWith(namespace) ? name.substring(namespace.length + 1) : '.' + name;
        callback(formattedEvent, data, metaData);
      });
      this.channel.subscribe(this.callbacks.get(callback));
      return this;
    }
    /**
     * Stop listening for an event on the channel instance.
     */
  }, {
    key: "stopListening",
    value: function stopListening(event, callback) {
      if (callback) {
        this.channel.unsubscribe(this.eventFormatter.format(event), this.callbacks.get(callback));
        this.callbacks["delete"](callback);
      } else {
        this.channel.unsubscribe(this.eventFormatter.format(event));
      }
      return this;
    }
    /**
     * Stop listening for all events on the channel instance.
     */
  }, {
    key: "stopListeningToAll",
    value: function stopListeningToAll(callback) {
      if (callback) {
        this.channel.unsubscribe(this.callbacks.get(callback));
        this.callbacks["delete"](callback);
      } else {
        this.channel.unsubscribe();
      }
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription succeeds.
     */
  }, {
    key: "subscribed",
    value: function subscribed(callback) {
      this.subscribedListeners.push(callback);
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription error occurs.
     */
  }, {
    key: "error",
    value: function error(callback) {
      this.errorListeners.push(callback);
      return this;
    }
    /**
     * Unregisters given error callback from the listeners.
     * @param callback
     * @returns AblyChannel
     */
  }, {
    key: "unregisterSubscribed",
    value: function unregisterSubscribed(callback) {
      if (callback) {
        this.subscribedListeners = this.subscribedListeners.filter(function (s) {
          return s != callback;
        });
      } else {
        this.subscribedListeners = [];
      }
      return this;
    }
    /**
     * Unregisters given error callback from the listeners.
     * @param callback
     * @returns AblyChannel
     */
  }, {
    key: "unregisterError",
    value: function unregisterError(callback) {
      if (callback) {
        this.errorListeners = this.errorListeners.filter(function (e) {
          return e != callback;
        });
      } else {
        this.errorListeners = [];
      }
      return this;
    }
  }]);
  return AblyChannel;
}(Channel);

var AblyPrivateChannel = /*#__PURE__*/function (_AblyChannel) {
  _inherits(AblyPrivateChannel, _AblyChannel);
  function AblyPrivateChannel(ably, name, options, auth) {
    var _this;
    _classCallCheck(this, AblyPrivateChannel);
    _this = _callSuper(this, AblyPrivateChannel, [ably, name, options, false]);
    _this.channel.on('failed', auth.onChannelFailed(_assertThisInitialized(_this)));
    _this.subscribe();
    return _this;
  }
  /**
   * Send a whisper event to other clients in the channel.
   */
  _createClass(AblyPrivateChannel, [{
    key: "whisper",
    value: function whisper(eventName, data, callback) {
      if (callback) {
        this.channel.publish("client-".concat(eventName), data, callback);
      } else {
        this.channel.publish("client-".concat(eventName), data);
      }
      return this;
    }
  }]);
  return AblyPrivateChannel;
}(AblyChannel);

/**
 * This class represents an Ably presence channel.
 */
var AblyPresenceChannel = /*#__PURE__*/function (_AblyChannel) {
  _inherits(AblyPresenceChannel, _AblyChannel);
  function AblyPresenceChannel(ably, name, options, auth) {
    var _this;
    _classCallCheck(this, AblyPresenceChannel);
    _this = _callSuper(this, AblyPresenceChannel, [ably, name, options, false]);
    _this.channel.on('failed', auth.onChannelFailed(_assertThisInitialized(_this)));
    _this.channel.on('attached', function () {
      return _this.enter(_this.presenceData, _this._alertErrorListeners);
    });
    _this.subscribe();
    return _this;
  }
  _createClass(AblyPresenceChannel, [{
    key: "unsubscribe",
    value: function unsubscribe() {
      this.leave(this.presenceData, this._alertErrorListeners);
      this.channel.presence.unsubscribe();
      _get(_getPrototypeOf(AblyPresenceChannel.prototype), "unsubscribe", this).call(this);
    }
    /**
     * Register a callback to be called anytime the member list changes.
     */
  }, {
    key: "here",
    value: function here(callback) {
      var _this2 = this;
      this.channel.presence.subscribe(['enter', 'update', 'leave'], function () {
        return _this2.channel.presence.get(function (err, members) {
          return callback(members.map(function (_ref) {
            var data = _ref.data;
            return data;
          }), err);
        });
      });
      return this;
    }
    /**
     * Listen for someone joining the channel.
     */
  }, {
    key: "joining",
    value: function joining(callback) {
      this.channel.presence.subscribe(['enter', 'update'], function (_a) {
        var data = _a.data,
          metaData = __rest(_a, ["data"]);
        callback(data, metaData);
      });
      return this;
    }
    /**
     * Listen for someone leaving the channel.
     */
  }, {
    key: "leaving",
    value: function leaving(callback) {
      this.channel.presence.subscribe('leave', function (_a) {
        var data = _a.data,
          metaData = __rest(_a, ["data"]);
        callback(data, metaData);
      });
      return this;
    }
    /**
     * Enter presence
     * @param data - Data to be published while entering the channel
     * @param callback - success/error callback (err) => {}
     * @returns AblyPresenceChannel
     */
  }, {
    key: "enter",
    value: function enter(data, callback) {
      this.channel.presence.enter(data, callback);
      return this;
    }
    /**
     * Leave presence
     * @param data - Data to be published while leaving the channel
     * @param callback - success/error callback (err) => {}
     * @returns AblyPresenceChannel
     */
  }, {
    key: "leave",
    value: function leave(data, callback) {
      this.channel.presence.leave(data, callback);
      return this;
    }
    /**
     * Update presence
     * @param data - Update presence with data
     * @param callback - success/error callback (err) => {}
     * @returns AblyPresenceChannel
     */
  }, {
    key: "update",
    value: function update(data, callback) {
      this.channel.presence.update(data, callback);
      return this;
    }
    /**
     * Send a whisper event to other clients in the channel.
     */
  }, {
    key: "whisper",
    value: function whisper(eventName, data, callback) {
      if (callback) {
        this.channel.publish("client-".concat(eventName), data, callback);
      } else {
        this.channel.publish("client-".concat(eventName), data);
      }
      return this;
    }
  }]);
  return AblyPresenceChannel;
}(AblyChannel);

var isNullOrUndefined = function isNullOrUndefined(obj) {
  return obj == null || obj === undefined;
};
/**
 * @throws Exception if parsing error
 */
var parseJwt = function parseJwt(jwtToken) {
  // Get Token Header
  var base64HeaderUrl = jwtToken.split('.')[0];
  var base64Header = base64HeaderUrl.replace('-', '+').replace('_', '/');
  var header = JSON.parse(toText(base64Header));
  // Get Token payload
  var base64Url = jwtToken.split('.')[1];
  var base64 = base64Url.replace('-', '+').replace('_', '/');
  var payload = JSON.parse(toText(base64));
  return {
    header: header,
    payload: payload
  };
};
// RSA4f - omitted `capability` property
var toTokenDetails = function toTokenDetails(jwtToken) {
  var _parseJwt = parseJwt(jwtToken),
    payload = _parseJwt.payload;
  return {
    clientId: payload['x-ably-clientId'],
    expires: payload.exp * 1000,
    issued: payload.iat * 1000,
    token: jwtToken
  };
};
var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object';
var toText = function toText(base64) {
  if (isBrowser) {
    return atob(base64);
  }
  return Buffer.from(base64, 'base64').toString('binary');
};
var isAbsoluteUrl = function isAbsoluteUrl(url) {
  return url && url.indexOf('http://') === 0 || url.indexOf('https://') === 0;
};
var fullUrl = function fullUrl(url) {
  var _a, _b, _c;
  if (!isAbsoluteUrl(url) && typeof window != 'undefined') {
    var host = (_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname;
    var port = (_b = window === null || window === void 0 ? void 0 : window.location) === null || _b === void 0 ? void 0 : _b.port;
    var protocol = (_c = window === null || window === void 0 ? void 0 : window.location) === null || _c === void 0 ? void 0 : _c.protocol.replace(':', '');
    if (host && port && protocol) {
      return protocol + '://' + host + ':' + port + url;
    }
  }
  return url;
};
var httpClient;
function httpRequest(options, callback) {
  if (!httpClient) {
    httpClient = new Ably.Rest.Platform.Http();
  }
  // Automatically set by browser
  if (isBrowser) {
    delete options.headers['Content-Length']; // XHR warning - Refused to set unsafe header "Content-Length"
  } else {
    options.method = options.method.toLowerCase();
  }
  httpClient.doUri(options.method, null, options.uri, options.headers, options.body, options.paramsIfNoHeaders || {}, callback);
}
var httpRequestAsync = function httpRequestAsync(options) {
  return new Promise(function (resolve, reject) {
    httpRequest(options, function (err, res) {
      if (err) {
        reject(err);
      } else {
        if (typeof res === 'string') {
          resolve(JSON.parse(res));
        } else if (!isBrowser && Buffer.isBuffer(res)) {
          try {
            resolve(JSON.parse(res.toString()));
          } catch (e) {
            resolve(res);
          }
        } else {
          resolve(res);
        }
      }
    });
  });
};

var channelAttachAuthorized = false;
/**
 * Modifies existing channel attach with custom authz implementation
 */
var beforeChannelAttach = function beforeChannelAttach(ablyClient, authorize) {
  var dummyRealtimeChannel = ablyClient.channels.get('dummy');
  dummyRealtimeChannel.__proto__.authorizeChannel = authorize;
  if (channelAttachAuthorized) {
    return;
  }
  var internalAttach = dummyRealtimeChannel.__proto__._attach;
  if (isNullOrUndefined(internalAttach)) {
    console.warn('Failed to enable authorize for pre-attach, please check for right library version');
    return;
  }
  function customInternalAttach(forceReattach, attachReason, errCallback) {
    var _this = this;
    if (this.authorizing) {
      return;
    }
    this.authorizing = true;
    var bindedInternalAttach = internalAttach.bind(this);
    this.authorizeChannel(this, function (error) {
      _this.authorizing = false;
      if (error) {
        if (errCallback) {
          errCallback(error);
        } else {
          console.error("channel ".concat(_this.name, " auth error => ").concat(error));
        }
        return;
      } else {
        bindedInternalAttach(forceReattach, attachReason, errCallback);
      }
    });
  }
  dummyRealtimeChannel.__proto__._attach = customInternalAttach;
  channelAttachAuthorized = true;
};

var SequentialAuthTokenRequestExecuter = /*#__PURE__*/_createClass(function SequentialAuthTokenRequestExecuter() {
  var _this = this;
  var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var requestTokenFn = arguments.length > 1 ? arguments[1] : undefined;
  _classCallCheck(this, SequentialAuthTokenRequestExecuter);
  this.execute = function (tokenRequestFn) {
    return new Promise(function (resolve, reject) {
      _this.queue.run(function () {
        return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var _yield$tokenRequestFn, _token, info;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return tokenRequestFn(this.cachedToken);
              case 3:
                _yield$tokenRequestFn = _context.sent;
                _token = _yield$tokenRequestFn.token;
                info = _yield$tokenRequestFn.info;
                this.cachedToken = _token;
                resolve({
                  token: _token,
                  info: info
                });
                _context.next = 13;
                break;
              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](0);
                reject(_context.t0);
              case 13:
              case "end":
                return _context.stop();
            }
          }, _callee, this, [[0, 10]]);
        }));
      });
    });
  };
  this.request = function (channelName) {
    return _this.execute(function (token) {
      return _this.requestTokenFn(channelName, token);
    });
  };
  this.cachedToken = token;
  this.requestTokenFn = requestTokenFn;
  this.queue = new TaskQueue();
});
var TaskQueue = /*#__PURE__*/_createClass(function TaskQueue() {
  var _this2 = this;
  var tasks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var concurrentCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  _classCallCheck(this, TaskQueue);
  this.canRunNext = function () {
    return _this2.running.length < _this2.count && _this2.todo.length;
  };
  this.run = function (task) {
    return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var currentTask;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (task) {
              this.todo.push(task);
            }
          case 1:
            if (!this.canRunNext()) {
              _context2.next = 9;
              break;
            }
            currentTask = this.todo.shift();
            this.running.push(currentTask);
            _context2.next = 6;
            return currentTask();
          case 6:
            this.running.shift();
            _context2.next = 1;
            break;
          case 9:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
  };
  this.total = tasks.length;
  this.todo = tasks;
  this.running = [];
  this.count = concurrentCount;
});

var AblyAuth = /*#__PURE__*/_createClass(function AblyAuth(ablyConnector, options) {
  var _this = this;
  _classCallCheck(this, AblyAuth);
  this.expiredAuthChannels = new Set();
  this.setExpired = function (channelName) {
    return _this.expiredAuthChannels.add(channelName);
  };
  this.isExpired = function (channelName) {
    return _this.expiredAuthChannels.has(channelName);
  };
  this.removeExpired = function (channelName) {
    return _this.expiredAuthChannels["delete"](channelName);
  };
  this.options = {
    queryTime: true,
    useTokenAuth: true,
    authCallback: function authCallback(_, callback) {
      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _yield$this$authReque, _token, tokenDetails;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this.authRequestExecuter.request(null);
            case 3:
              _yield$this$authReque = _context.sent;
              _token = _yield$this$authReque.token;
              tokenDetails = toTokenDetails(_token);
              callback(null, tokenDetails);
              _context.next = 12;
              break;
            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](0);
              callback(_context.t0, null);
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 9]]);
      }));
    },
    echoMessages: false // https://docs.ably.io/client-lib-development-guide/features/#TO3h
  };
  this.requestToken = function (channelName, existingToken) {
    return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var postData, postOptions;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            postData = JSON.stringify({
              channel_name: channelName,
              token: existingToken
            });
            postOptions = {
              uri: this.authEndpoint,
              method: 'POST',
              headers: _extends({
                Accept: 'application/json',
                'Content-Type': 'application/json',
                'Content-Length': postData.length
              }, this.authHeaders),
              body: postData
            };
            _context2.next = 4;
            return httpRequestAsync(postOptions);
          case 4:
            return _context2.abrupt("return", _context2.sent);
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
  };
  this.ablyClient = function () {
    return _this.ablyConnector.ably;
  };
  this.existingToken = function () {
    return _this.ablyClient().auth.tokenDetails;
  };
  this.getChannel = function (name) {
    return _this.ablyConnector.channels[name];
  };
  this.enableAuthorizeBeforeChannelAttach = function () {
    var ablyClient = _this.ablyClient();
    ablyClient.auth.getTimestamp(_this.options.queryTime, function () {
      return void 0;
    }); // generates serverTimeOffset in the background
    beforeChannelAttach(ablyClient, function (realtimeChannel, errorCallback) {
      var channelName = realtimeChannel.name;
      if (channelName.startsWith('public:')) {
        errorCallback(null);
        return;
      }
      // Use cached token if has channel capability and is not expired
      var tokenDetails = _this.existingToken();
      if (tokenDetails && !_this.isExpired(channelName)) {
        var capability = parseJwt(tokenDetails.token).payload['x-ably-capability'];
        var tokenHasChannelCapability = capability.includes("".concat(channelName, "\""));
        // checks with server time using offset, otherwise local time
        if (tokenHasChannelCapability && tokenDetails.expires > ablyClient.auth.getTimestampUsingOffset()) {
          errorCallback(null);
          return;
        }
      }
      // explicitly request token for given channel name
      _this.authRequestExecuter.request(channelName).then(function (_ref) {
        var jwtToken = _ref.token,
          info = _ref.info;
        // get upgraded token with channel access
        var echoChannel = _this.getChannel(channelName);
        _this.setPresenceInfo(echoChannel, info);
        _this.tryAuthorizeOnSameConnection(_extends(_extends({}, _this.options), {
          token: toTokenDetails(jwtToken)
        }), function (err, _tokenDetails) {
          if (err) {
            errorCallback(err);
          } else {
            _this.removeExpired(channelName);
            errorCallback(null);
          }
        });
      })["catch"](function (err) {
        return errorCallback(err);
      });
    });
  };
  this.allowReconnectOnUserLogin = function () {
    var ablyConnection = _this.ablyClient().connection;
    var connectionFailedCallback = function connectionFailedCallback(stateChange) {
      if (stateChange.reason.code == 40102) {
        // 40102 denotes mismatched clientId
        ablyConnection.off(connectionFailedCallback);
        console.warn("User login detected, re-connecting again!");
        _this.onClientIdChanged();
      }
    };
    ablyConnection.on('failed', connectionFailedCallback);
  };
  /**
   * This will be called when (guest)user logs in and new clientId is returned in the jwt token.
   * If client tries to authenticate with new clientId on same connection, ably server returns
   * error and connection goes into failed state.
   * See https://github.com/ably/laravel-broadcaster/issues/45 for more details.
   * There's a separate test case added for user login flow => ably-user-login.test.ts.
   */
  this.onClientIdChanged = function () {
    _this.ablyClient().connect();
    for (var _i = 0, _Object$values = Object.values(_this.ablyConnector.channels); _i < _Object$values.length; _i++) {
      var ablyChannel = _Object$values[_i];
      ablyChannel.channel.attach(ablyChannel._alertErrorListeners);
    }
  };
  this.tryAuthorizeOnSameConnection = function (authOptions, callback) {
    _this.ablyClient().auth.authorize(null, authOptions, callback);
  };
  this.onChannelFailed = function (echoAblyChannel) {
    return function (stateChange) {
      var _a;
      // channel capability rejected https://help.ably.io/error/40160
      if (((_a = stateChange.reason) === null || _a === void 0 ? void 0 : _a.code) == 40160) {
        _this.handleChannelAuthError(echoAblyChannel);
      }
    };
  };
  this.handleChannelAuthError = function (echoAblyChannel) {
    if (echoAblyChannel.skipAuth) {
      return;
    }
    var channelName = echoAblyChannel.name;
    // get upgraded token with channel access
    _this.authRequestExecuter.request(channelName).then(function (_ref2) {
      var jwtToken = _ref2.token,
        info = _ref2.info;
      _this.setPresenceInfo(echoAblyChannel, info);
      _this.tryAuthorizeOnSameConnection(_extends(_extends({}, _this.options), {
        token: toTokenDetails(jwtToken)
      }), function (err, _tokenDetails) {
        if (err) {
          echoAblyChannel._alertErrorListeners(err);
        } else {
          echoAblyChannel.skipAuth = true;
          echoAblyChannel.channel.once('attached', function () {
            echoAblyChannel.skipAuth = false;
          });
          echoAblyChannel.channel.attach(echoAblyChannel._alertErrorListeners);
        }
      });
    })["catch"](function (err) {
      return echoAblyChannel._alertErrorListeners(err);
    });
  };
  this.setPresenceInfo = function (echoAblyChannel, info) {
    if (echoAblyChannel instanceof AblyPresenceChannel) {
      echoAblyChannel.presenceData = info;
    }
  };
  this.ablyConnector = ablyConnector;
  var authEndpoint = options.authEndpoint,
    headers = options.auth.headers,
    token = options.token,
    requestTokenFn = options.requestTokenFn;
  this.authEndpoint = fullUrl(authEndpoint);
  this.authHeaders = headers;
  this.authRequestExecuter = new SequentialAuthTokenRequestExecuter(token, requestTokenFn !== null && requestTokenFn !== void 0 ? requestTokenFn : this.requestToken);
});

/**
 * This class represents a Pusher channel.
 */
var PusherChannel = /*#__PURE__*/function (_Channel) {
  _inherits(PusherChannel, _Channel);
  /**
   * Create a new class instance.
   */
  function PusherChannel(pusher, name, options) {
    var _this;
    _classCallCheck(this, PusherChannel);
    _this = _callSuper(this, PusherChannel);
    _this.name = name;
    _this.pusher = pusher;
    _this.options = options;
    _this.eventFormatter = new EventFormatter(_this.options.namespace);
    _this.subscribe();
    return _this;
  }
  /**
   * Subscribe to a Pusher channel.
   */
  _createClass(PusherChannel, [{
    key: "subscribe",
    value: function subscribe() {
      this.subscription = this.pusher.subscribe(this.name);
    }
    /**
     * Unsubscribe from a Pusher channel.
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      this.pusher.unsubscribe(this.name);
    }
    /**
     * Listen for an event on the channel instance.
     */
  }, {
    key: "listen",
    value: function listen(event, callback) {
      this.on(this.eventFormatter.format(event), callback);
      return this;
    }
    /**
     * Listen for all events on the channel instance.
     */
  }, {
    key: "listenToAll",
    value: function listenToAll(callback) {
      var _this2 = this;
      this.subscription.bind_global(function (event, data) {
        if (event.startsWith('pusher:')) {
          return;
        }
        var namespace = _this2.options.namespace.replace(/\./g, '\\');
        var formattedEvent = event.startsWith(namespace) ? event.substring(namespace.length + 1) : '.' + event;
        callback(formattedEvent, data);
      });
      return this;
    }
    /**
     * Stop listening for an event on the channel instance.
     */
  }, {
    key: "stopListening",
    value: function stopListening(event, callback) {
      if (callback) {
        this.subscription.unbind(this.eventFormatter.format(event), callback);
      } else {
        this.subscription.unbind(this.eventFormatter.format(event));
      }
      return this;
    }
    /**
     * Stop listening for all events on the channel instance.
     */
  }, {
    key: "stopListeningToAll",
    value: function stopListeningToAll(callback) {
      if (callback) {
        this.subscription.unbind_global(callback);
      } else {
        this.subscription.unbind_global();
      }
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription succeeds.
     */
  }, {
    key: "subscribed",
    value: function subscribed(callback) {
      this.on('pusher:subscription_succeeded', function () {
        callback();
      });
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription error occurs.
     */
  }, {
    key: "error",
    value: function error(callback) {
      this.on('pusher:subscription_error', function (status) {
        callback(status);
      });
      return this;
    }
    /**
     * Bind a channel to an event.
     */
  }, {
    key: "on",
    value: function on(event, callback) {
      this.subscription.bind(event, callback);
      return this;
    }
  }]);
  return PusherChannel;
}(Channel);

/**
 * This class represents a Pusher private channel.
 */
var PusherPrivateChannel = /*#__PURE__*/function (_PusherChannel) {
  _inherits(PusherPrivateChannel, _PusherChannel);
  function PusherPrivateChannel() {
    _classCallCheck(this, PusherPrivateChannel);
    return _callSuper(this, PusherPrivateChannel, arguments);
  }
  _createClass(PusherPrivateChannel, [{
    key: "whisper",
    value:
    /**
     * Send a whisper event to other clients in the channel.
     */
    function whisper(eventName, data) {
      this.pusher.channels.channels[this.name].trigger("client-".concat(eventName), data);
      return this;
    }
  }]);
  return PusherPrivateChannel;
}(PusherChannel);

/**
 * This class represents a Pusher private channel.
 */
var PusherEncryptedPrivateChannel = /*#__PURE__*/function (_PusherChannel) {
  _inherits(PusherEncryptedPrivateChannel, _PusherChannel);
  function PusherEncryptedPrivateChannel() {
    _classCallCheck(this, PusherEncryptedPrivateChannel);
    return _callSuper(this, PusherEncryptedPrivateChannel, arguments);
  }
  _createClass(PusherEncryptedPrivateChannel, [{
    key: "whisper",
    value:
    /**
     * Send a whisper event to other clients in the channel.
     */
    function whisper(eventName, data) {
      this.pusher.channels.channels[this.name].trigger("client-".concat(eventName), data);
      return this;
    }
  }]);
  return PusherEncryptedPrivateChannel;
}(PusherChannel);

/**
 * This class represents a Pusher presence channel.
 */
var PusherPresenceChannel = /*#__PURE__*/function (_PusherChannel) {
  _inherits(PusherPresenceChannel, _PusherChannel);
  function PusherPresenceChannel() {
    _classCallCheck(this, PusherPresenceChannel);
    return _callSuper(this, PusherPresenceChannel, arguments);
  }
  _createClass(PusherPresenceChannel, [{
    key: "here",
    value:
    /**
     * Register a callback to be called anytime the member list changes.
     */
    function here(callback) {
      this.on('pusher:subscription_succeeded', function (data) {
        callback(Object.keys(data.members).map(function (k) {
          return data.members[k];
        }));
      });
      return this;
    }
    /**
     * Listen for someone joining the channel.
     */
  }, {
    key: "joining",
    value: function joining(callback) {
      this.on('pusher:member_added', function (member) {
        callback(member.info);
      });
      return this;
    }
    /**
     * Send a whisper event to other clients in the channel.
     */
  }, {
    key: "whisper",
    value: function whisper(eventName, data) {
      this.pusher.channels.channels[this.name].trigger("client-".concat(eventName), data);
      return this;
    }
    /**
     * Listen for someone leaving the channel.
     */
  }, {
    key: "leaving",
    value: function leaving(callback) {
      this.on('pusher:member_removed', function (member) {
        callback(member.info);
      });
      return this;
    }
  }]);
  return PusherPresenceChannel;
}(PusherChannel);

/**
 * This class represents a Socket.io channel.
 */
var SocketIoChannel = /*#__PURE__*/function (_Channel) {
  _inherits(SocketIoChannel, _Channel);
  /**
   * Create a new class instance.
   */
  function SocketIoChannel(socket, name, options) {
    var _this;
    _classCallCheck(this, SocketIoChannel);
    _this = _callSuper(this, SocketIoChannel);
    /**
     * The event callbacks applied to the socket.
     */
    _this.events = {};
    /**
     * User supplied callbacks for events on this channel.
     */
    _this.listeners = {};
    _this.name = name;
    _this.socket = socket;
    _this.options = options;
    _this.eventFormatter = new EventFormatter(_this.options.namespace);
    _this.subscribe();
    return _this;
  }
  /**
   * Subscribe to a Socket.io channel.
   */
  _createClass(SocketIoChannel, [{
    key: "subscribe",
    value: function subscribe() {
      this.socket.emit('subscribe', {
        channel: this.name,
        auth: this.options.auth || {}
      });
    }
    /**
     * Unsubscribe from channel and ubind event callbacks.
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      this.unbind();
      this.socket.emit('unsubscribe', {
        channel: this.name,
        auth: this.options.auth || {}
      });
    }
    /**
     * Listen for an event on the channel instance.
     */
  }, {
    key: "listen",
    value: function listen(event, callback) {
      this.on(this.eventFormatter.format(event), callback);
      return this;
    }
    /**
     * Stop listening for an event on the channel instance.
     */
  }, {
    key: "stopListening",
    value: function stopListening(event, callback) {
      this.unbindEvent(this.eventFormatter.format(event), callback);
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription succeeds.
     */
  }, {
    key: "subscribed",
    value: function subscribed(callback) {
      this.on('connect', function (socket) {
        callback(socket);
      });
      return this;
    }
    /**
     * Register a callback to be called anytime an error occurs.
     */
  }, {
    key: "error",
    value: function error(callback) {
      return this;
    }
    /**
     * Bind the channel's socket to an event and store the callback.
     */
  }, {
    key: "on",
    value: function on(event, callback) {
      var _this2 = this;
      this.listeners[event] = this.listeners[event] || [];
      if (!this.events[event]) {
        this.events[event] = function (channel, data) {
          if (_this2.name === channel && _this2.listeners[event]) {
            _this2.listeners[event].forEach(function (cb) {
              return cb(data);
            });
          }
        };
        this.socket.on(event, this.events[event]);
      }
      this.listeners[event].push(callback);
      return this;
    }
    /**
     * Unbind the channel's socket from all stored event callbacks.
     */
  }, {
    key: "unbind",
    value: function unbind() {
      var _this3 = this;
      Object.keys(this.events).forEach(function (event) {
        _this3.unbindEvent(event);
      });
    }
    /**
     * Unbind the listeners for the given event.
     */
  }, {
    key: "unbindEvent",
    value: function unbindEvent(event, callback) {
      this.listeners[event] = this.listeners[event] || [];
      if (callback) {
        this.listeners[event] = this.listeners[event].filter(function (cb) {
          return cb !== callback;
        });
      }
      if (!callback || this.listeners[event].length === 0) {
        if (this.events[event]) {
          this.socket.removeListener(event, this.events[event]);
          delete this.events[event];
        }
        delete this.listeners[event];
      }
    }
  }]);
  return SocketIoChannel;
}(Channel);

/**
 * This class represents a Socket.io private channel.
 */
var SocketIoPrivateChannel = /*#__PURE__*/function (_SocketIoChannel) {
  _inherits(SocketIoPrivateChannel, _SocketIoChannel);
  function SocketIoPrivateChannel() {
    _classCallCheck(this, SocketIoPrivateChannel);
    return _callSuper(this, SocketIoPrivateChannel, arguments);
  }
  _createClass(SocketIoPrivateChannel, [{
    key: "whisper",
    value:
    /**
     * Send a whisper event to other clients in the channel.
     */
    function whisper(eventName, data) {
      this.socket.emit('client event', {
        channel: this.name,
        event: "client-".concat(eventName),
        data: data
      });
      return this;
    }
  }]);
  return SocketIoPrivateChannel;
}(SocketIoChannel);

/**
 * This class represents a Socket.io presence channel.
 */
var SocketIoPresenceChannel = /*#__PURE__*/function (_SocketIoPrivateChann) {
  _inherits(SocketIoPresenceChannel, _SocketIoPrivateChann);
  function SocketIoPresenceChannel() {
    _classCallCheck(this, SocketIoPresenceChannel);
    return _callSuper(this, SocketIoPresenceChannel, arguments);
  }
  _createClass(SocketIoPresenceChannel, [{
    key: "here",
    value:
    /**
     * Register a callback to be called anytime the member list changes.
     */
    function here(callback) {
      this.on('presence:subscribed', function (members) {
        callback(members.map(function (m) {
          return m.user_info;
        }));
      });
      return this;
    }
    /**
     * Listen for someone joining the channel.
     */
  }, {
    key: "joining",
    value: function joining(callback) {
      this.on('presence:joining', function (member) {
        return callback(member.user_info);
      });
      return this;
    }
    /**
     * Send a whisper event to other clients in the channel.
     */
  }, {
    key: "whisper",
    value: function whisper(eventName, data) {
      this.socket.emit('client event', {
        channel: this.name,
        event: "client-".concat(eventName),
        data: data
      });
      return this;
    }
    /**
     * Listen for someone leaving the channel.
     */
  }, {
    key: "leaving",
    value: function leaving(callback) {
      this.on('presence:leaving', function (member) {
        return callback(member.user_info);
      });
      return this;
    }
  }]);
  return SocketIoPresenceChannel;
}(SocketIoPrivateChannel);

/**
 * This class represents a null channel.
 */
var NullChannel = /*#__PURE__*/function (_Channel) {
  _inherits(NullChannel, _Channel);
  function NullChannel() {
    _classCallCheck(this, NullChannel);
    return _callSuper(this, NullChannel, arguments);
  }
  _createClass(NullChannel, [{
    key: "subscribe",
    value:
    /**
     * Subscribe to a channel.
     */
    function subscribe() {
      //
    }
    /**
     * Unsubscribe from a channel.
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      //
    }
    /**
     * Listen for an event on the channel instance.
     */
  }, {
    key: "listen",
    value: function listen(event, callback) {
      return this;
    }
    /**
     * Listen for all events on the channel instance.
     */
  }, {
    key: "listenToAll",
    value: function listenToAll(callback) {
      return this;
    }
    /**
     * Stop listening for an event on the channel instance.
     */
  }, {
    key: "stopListening",
    value: function stopListening(event, callback) {
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription succeeds.
     */
  }, {
    key: "subscribed",
    value: function subscribed(callback) {
      return this;
    }
    /**
     * Register a callback to be called anytime an error occurs.
     */
  }, {
    key: "error",
    value: function error(callback) {
      return this;
    }
    /**
     * Bind a channel to an event.
     */
  }, {
    key: "on",
    value: function on(event, callback) {
      return this;
    }
  }]);
  return NullChannel;
}(Channel);

/**
 * This class represents a null private channel.
 */
var NullPrivateChannel = /*#__PURE__*/function (_NullChannel) {
  _inherits(NullPrivateChannel, _NullChannel);
  function NullPrivateChannel() {
    _classCallCheck(this, NullPrivateChannel);
    return _callSuper(this, NullPrivateChannel, arguments);
  }
  _createClass(NullPrivateChannel, [{
    key: "whisper",
    value:
    /**
     * Send a whisper event to other clients in the channel.
     */
    function whisper(eventName, data) {
      return this;
    }
  }]);
  return NullPrivateChannel;
}(NullChannel);

/**
 * This class represents a null presence channel.
 */
var NullPresenceChannel = /*#__PURE__*/function (_NullChannel) {
  _inherits(NullPresenceChannel, _NullChannel);
  function NullPresenceChannel() {
    _classCallCheck(this, NullPresenceChannel);
    return _callSuper(this, NullPresenceChannel, arguments);
  }
  _createClass(NullPresenceChannel, [{
    key: "here",
    value:
    /**
     * Register a callback to be called anytime the member list changes.
     */
    function here(callback) {
      return this;
    }
    /**
     * Listen for someone joining the channel.
     */
  }, {
    key: "joining",
    value: function joining(callback) {
      return this;
    }
    /**
     * Send a whisper event to other clients in the channel.
     */
  }, {
    key: "whisper",
    value: function whisper(eventName, data) {
      return this;
    }
    /**
     * Listen for someone leaving the channel.
     */
  }, {
    key: "leaving",
    value: function leaving(callback) {
      return this;
    }
  }]);
  return NullPresenceChannel;
}(NullChannel);

var Connector = /*#__PURE__*/function () {
  /**
   * Create a new class instance.
   */
  function Connector(options) {
    _classCallCheck(this, Connector);
    /**
     * Default connector options.
     */
    this._defaultOptions = {
      auth: {
        headers: {}
      },
      authEndpoint: '/broadcasting/auth',
      userAuthentication: {
        endpoint: '/broadcasting/user-auth',
        headers: {}
      },
      broadcaster: 'pusher',
      csrfToken: null,
      bearerToken: null,
      host: null,
      key: null,
      namespace: 'App.Events'
    };
    this.setOptions(options);
    this.connect();
  }
  /**
   * Merge the custom options with the defaults.
   */
  _createClass(Connector, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = _extends(this._defaultOptions, options);
      var token = this.csrfToken();
      if (token) {
        this.options.auth.headers['X-CSRF-TOKEN'] = token;
        this.options.userAuthentication.headers['X-CSRF-TOKEN'] = token;
      }
      token = this.options.bearerToken;
      if (token) {
        this.options.auth.headers['Authorization'] = 'Bearer ' + token;
        this.options.userAuthentication.headers['Authorization'] = 'Bearer ' + token;
      }
      return options;
    }
    /**
     * Extract the CSRF token from the page.
     */
  }, {
    key: "csrfToken",
    value: function csrfToken() {
      var selector;
      if (typeof window !== 'undefined' && window['Laravel'] && window['Laravel'].csrfToken) {
        return window['Laravel'].csrfToken;
      } else if (this.options.csrfToken) {
        return this.options.csrfToken;
      } else if (typeof document !== 'undefined' && typeof document.querySelector === 'function' && (selector = document.querySelector('meta[name="csrf-token"]'))) {
        return selector.getAttribute('content');
      }
      return null;
    }
  }]);
  return Connector;
}();

/**
 * This class creates a connector to Pusher.
 */
var PusherConnector = /*#__PURE__*/function (_Connector) {
  _inherits(PusherConnector, _Connector);
  function PusherConnector() {
    var _this;
    _classCallCheck(this, PusherConnector);
    _this = _callSuper(this, PusherConnector, arguments);
    /**
     * All of the subscribed channel names.
     */
    _this.channels = {};
    return _this;
  }
  /**
   * Create a fresh Pusher connection.
   */
  _createClass(PusherConnector, [{
    key: "connect",
    value: function connect() {
      if (typeof this.options.client !== 'undefined') {
        this.pusher = this.options.client;
      } else if (this.options.Pusher) {
        this.pusher = new this.options.Pusher(this.options.key, this.options);
      } else {
        this.pusher = new Pusher(this.options.key, this.options);
      }
    }
    /**
     * Sign in the user via Pusher user authentication (https://pusher.com/docs/channels/using_channels/user-authentication/).
     */
  }, {
    key: "signin",
    value: function signin() {
      this.pusher.signin();
    }
    /**
     * Listen for an event on a channel instance.
     */
  }, {
    key: "listen",
    value: function listen(name, event, callback) {
      return this.channel(name).listen(event, callback);
    }
    /**
     * Get a channel instance by name.
     */
  }, {
    key: "channel",
    value: function channel(name) {
      if (!this.channels[name]) {
        this.channels[name] = new PusherChannel(this.pusher, name, this.options);
      }
      return this.channels[name];
    }
    /**
     * Get a private channel instance by name.
     */
  }, {
    key: "privateChannel",
    value: function privateChannel(name) {
      if (!this.channels['private-' + name]) {
        this.channels['private-' + name] = new PusherPrivateChannel(this.pusher, 'private-' + name, this.options);
      }
      return this.channels['private-' + name];
    }
    /**
     * Get a private encrypted channel instance by name.
     */
  }, {
    key: "encryptedPrivateChannel",
    value: function encryptedPrivateChannel(name) {
      if (!this.channels['private-encrypted-' + name]) {
        this.channels['private-encrypted-' + name] = new PusherEncryptedPrivateChannel(this.pusher, 'private-encrypted-' + name, this.options);
      }
      return this.channels['private-encrypted-' + name];
    }
    /**
     * Get a presence channel instance by name.
     */
  }, {
    key: "presenceChannel",
    value: function presenceChannel(name) {
      if (!this.channels['presence-' + name]) {
        this.channels['presence-' + name] = new PusherPresenceChannel(this.pusher, 'presence-' + name, this.options);
      }
      return this.channels['presence-' + name];
    }
    /**
     * Leave the given channel, as well as its private and presence variants.
     */
  }, {
    key: "leave",
    value: function leave(name) {
      var _this2 = this;
      var channels = [name, 'private-' + name, 'private-encrypted-' + name, 'presence-' + name];
      channels.forEach(function (name, index) {
        _this2.leaveChannel(name);
      });
    }
    /**
     * Leave the given channel.
     */
  }, {
    key: "leaveChannel",
    value: function leaveChannel(name) {
      if (this.channels[name]) {
        this.channels[name].unsubscribe();
        delete this.channels[name];
      }
    }
    /**
     * Get the socket ID for the connection.
     */
  }, {
    key: "socketId",
    value: function socketId() {
      return this.pusher.connection.socket_id;
    }
    /**
     * Disconnect Pusher connection.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.pusher.disconnect();
    }
  }]);
  return PusherConnector;
}(Connector);

/**
 * This class creates a connnector to a Socket.io server.
 */
var SocketIoConnector = /*#__PURE__*/function (_Connector) {
  _inherits(SocketIoConnector, _Connector);
  function SocketIoConnector() {
    var _this;
    _classCallCheck(this, SocketIoConnector);
    _this = _callSuper(this, SocketIoConnector, arguments);
    /**
     * All of the subscribed channel names.
     */
    _this.channels = {};
    return _this;
  }
  /**
   * Create a fresh Socket.io connection.
   */
  _createClass(SocketIoConnector, [{
    key: "connect",
    value: function connect() {
      var _this2 = this;
      var io = this.getSocketIO();
      this.socket = io(this.options.host, this.options);
      this.socket.on('reconnect', function () {
        Object.values(_this2.channels).forEach(function (channel) {
          channel.subscribe();
        });
      });
      return this.socket;
    }
    /**
     * Get socket.io module from global scope or options.
     */
  }, {
    key: "getSocketIO",
    value: function getSocketIO() {
      if (typeof this.options.client !== 'undefined') {
        return this.options.client;
      }
      if (typeof io !== 'undefined') {
        return io;
      }
      throw new Error('Socket.io client not found. Should be globally available or passed via options.client');
    }
    /**
     * Listen for an event on a channel instance.
     */
  }, {
    key: "listen",
    value: function listen(name, event, callback) {
      return this.channel(name).listen(event, callback);
    }
    /**
     * Get a channel instance by name.
     */
  }, {
    key: "channel",
    value: function channel(name) {
      if (!this.channels[name]) {
        this.channels[name] = new SocketIoChannel(this.socket, name, this.options);
      }
      return this.channels[name];
    }
    /**
     * Get a private channel instance by name.
     */
  }, {
    key: "privateChannel",
    value: function privateChannel(name) {
      if (!this.channels['private-' + name]) {
        this.channels['private-' + name] = new SocketIoPrivateChannel(this.socket, 'private-' + name, this.options);
      }
      return this.channels['private-' + name];
    }
    /**
     * Get a presence channel instance by name.
     */
  }, {
    key: "presenceChannel",
    value: function presenceChannel(name) {
      if (!this.channels['presence-' + name]) {
        this.channels['presence-' + name] = new SocketIoPresenceChannel(this.socket, 'presence-' + name, this.options);
      }
      return this.channels['presence-' + name];
    }
    /**
     * Leave the given channel, as well as its private and presence variants.
     */
  }, {
    key: "leave",
    value: function leave(name) {
      var _this3 = this;
      var channels = [name, 'private-' + name, 'presence-' + name];
      channels.forEach(function (name) {
        _this3.leaveChannel(name);
      });
    }
    /**
     * Leave the given channel.
     */
  }, {
    key: "leaveChannel",
    value: function leaveChannel(name) {
      if (this.channels[name]) {
        this.channels[name].unsubscribe();
        delete this.channels[name];
      }
    }
    /**
     * Get the socket ID for the connection.
     */
  }, {
    key: "socketId",
    value: function socketId() {
      return this.socket.id;
    }
    /**
     * Disconnect Socketio connection.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.socket.disconnect();
    }
  }]);
  return SocketIoConnector;
}(Connector);

/**
 * This class creates a null connector.
 */
var NullConnector = /*#__PURE__*/function (_Connector) {
  _inherits(NullConnector, _Connector);
  function NullConnector() {
    var _this;
    _classCallCheck(this, NullConnector);
    _this = _callSuper(this, NullConnector, arguments);
    /**
     * All of the subscribed channel names.
     */
    _this.channels = {};
    return _this;
  }
  /**
   * Create a fresh connection.
   */
  _createClass(NullConnector, [{
    key: "connect",
    value: function connect() {
      //
    }
    /**
     * Listen for an event on a channel instance.
     */
  }, {
    key: "listen",
    value: function listen(name, event, callback) {
      return new NullChannel();
    }
    /**
     * Get a channel instance by name.
     */
  }, {
    key: "channel",
    value: function channel(name) {
      return new NullChannel();
    }
    /**
     * Get a private channel instance by name.
     */
  }, {
    key: "privateChannel",
    value: function privateChannel(name) {
      return new NullPrivateChannel();
    }
    /**
     * Get a private encrypted channel instance by name.
     */
  }, {
    key: "encryptedPrivateChannel",
    value: function encryptedPrivateChannel(name) {
      return new NullPrivateChannel();
    }
    /**
     * Get a presence channel instance by name.
     */
  }, {
    key: "presenceChannel",
    value: function presenceChannel(name) {
      return new NullPresenceChannel();
    }
    /**
     * Leave the given channel, as well as its private and presence variants.
     */
  }, {
    key: "leave",
    value: function leave(name) {
      //
    }
    /**
     * Leave the given channel.
     */
  }, {
    key: "leaveChannel",
    value: function leaveChannel(name) {
      //
    }
    /**
     * Get the socket ID for the connection.
     */
  }, {
    key: "socketId",
    value: function socketId() {
      return 'fake-socket-id';
    }
    /**
     * Disconnect the connection.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      //
    }
  }]);
  return NullConnector;
}(Connector);

/**
 * This class creates a connector to Ably.
 */
var AblyConnector = /*#__PURE__*/function (_Connector) {
  _inherits(AblyConnector, _Connector);
  function AblyConnector() {
    var _this;
    _classCallCheck(this, AblyConnector);
    _this = _callSuper(this, AblyConnector, arguments);
    /**
     * All of the subscribed channel names.
     */
    _this.channels = {};
    return _this;
  }
  /**
   * Create a fresh Ably connection.
   */
  _createClass(AblyConnector, [{
    key: "connect",
    value: function connect() {
      if (typeof this.options.client !== 'undefined') {
        this.ably = this.options.client;
      } else {
        this.ablyAuth = new AblyAuth(this, this.options);
        if (!this.options.agents) {
          this.options.agents = {};
        }
        this.options.agents['laravel-echo'] = AblyConnector.LIB_VERSION;
        this.ably = new Ably.Realtime(_extends(_extends({}, this.ablyAuth.options), this.options));
        this.ablyAuth.enableAuthorizeBeforeChannelAttach();
        this.ablyAuth.allowReconnectOnUserLogin();
      }
    }
    /**
     * Listen for an event on a channel instance.
     */
  }, {
    key: "listen",
    value: function listen(name, event, callback) {
      return this.channel(name).listen(event, callback);
    }
    /**
     * Get a channel instance by name.
     */
  }, {
    key: "channel",
    value: function channel(name) {
      var prefixedName = "public:".concat(name); // adding public as a ably namespace prefix
      if (!this.channels[prefixedName]) {
        this.channels[prefixedName] = new AblyChannel(this.ably, prefixedName, this.options);
      }
      return this.channels[prefixedName];
    }
    /**
     * Get a private channel instance by name.
     */
  }, {
    key: "privateChannel",
    value: function privateChannel(name) {
      var prefixedName = "private:".concat(name); // adding private as a ably namespace prefix
      if (!this.channels[prefixedName]) {
        this.channels[prefixedName] = new AblyPrivateChannel(this.ably, prefixedName, this.options, this.ablyAuth);
      }
      return this.channels[prefixedName];
    }
    /**
     * Get a presence channel instance by name.
     */
  }, {
    key: "presenceChannel",
    value: function presenceChannel(name) {
      var prefixedName = "presence:".concat(name); // adding presence as a ably namespace prefix
      if (!this.channels[prefixedName]) {
        this.channels[prefixedName] = new AblyPresenceChannel(this.ably, prefixedName, this.options, this.ablyAuth);
      }
      return this.channels[prefixedName];
    }
    /**
     * Leave the given channel, as well as its private and presence variants.
     */
  }, {
    key: "leave",
    value: function leave(name) {
      var _this2 = this;
      var channels = ["public:".concat(name), "private:".concat(name), "presence:".concat(name)];
      channels.forEach(function (name, index) {
        _this2.leaveChannel(name);
      });
    }
    /**
     * Leave the given channel.
     */
  }, {
    key: "leaveChannel",
    value: function leaveChannel(name) {
      if (name.indexOf('public:') !== 0 && name.indexOf('private:') !== 0 && name.indexOf('presence:') !== 0) {
        throw new Error("Error leaving ".concat(name, ", name should be prefixed with either \"public:\", \"private:\" or \"presence:\""));
      }
      if (this.channels[name]) {
        this.channels[name].unsubscribe();
        this.ablyAuth.setExpired(name);
        delete this.channels[name];
      }
    }
    /**
     * Get the socket ID for the connection.
     */
  }, {
    key: "socketId",
    value: function socketId() {
      return this.ably.connection.key;
    }
    /**
     * Disconnect Ably connection.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.ably.close();
    }
  }]);
  return AblyConnector;
}(Connector);
/**
 * The laravel-echo library version.
 */
AblyConnector.LIB_VERSION = '1.0.5';

/**
 * This class is the primary API for interacting with broadcasting.
 */
var Echo = /*#__PURE__*/function () {
  /**
   * Create a new class instance.
   */
  function Echo(options) {
    _classCallCheck(this, Echo);
    this.options = options;
    this.connect();
    if (!this.options.withoutInterceptors) {
      this.registerInterceptors();
    }
  }
  /**
   * Get a channel instance by name.
   */
  _createClass(Echo, [{
    key: "channel",
    value: function channel(_channel) {
      return this.connector.channel(_channel);
    }
    /**
     * Create a new connection.
     */
  }, {
    key: "connect",
    value: function connect() {
      if (this.options.broadcaster == 'ably') {
        this.connector = new AblyConnector(this.options);
      } else if (this.options.broadcaster == 'reverb') {
        this.connector = new PusherConnector(_extends(_extends({}, this.options), {
          cluster: ''
        }));
      } else if (this.options.broadcaster == 'pusher') {
        this.connector = new PusherConnector(this.options);
      } else if (this.options.broadcaster == 'socket.io') {
        this.connector = new SocketIoConnector(this.options);
      } else if (this.options.broadcaster == 'null') {
        this.connector = new NullConnector(this.options);
      } else if (typeof this.options.broadcaster == 'function') {
        this.connector = new this.options.broadcaster(this.options);
      } else {
        throw new Error("Broadcaster ".concat(_typeof(this.options.broadcaster), " ").concat(this.options.broadcaster, " is not supported."));
      }
    }
    /**
     * Disconnect from the Echo server.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.connector.disconnect();
    }
    /**
     * Get a presence channel instance by name.
     */
  }, {
    key: "join",
    value: function join(channel) {
      return this.connector.presenceChannel(channel);
    }
    /**
     * Leave the given channel, as well as its private and presence variants.
     */
  }, {
    key: "leave",
    value: function leave(channel) {
      this.connector.leave(channel);
    }
    /**
     * Leave the given channel.
     */
  }, {
    key: "leaveChannel",
    value: function leaveChannel(channel) {
      this.connector.leaveChannel(channel);
    }
    /**
     * Leave all channels.
     */
  }, {
    key: "leaveAllChannels",
    value: function leaveAllChannels() {
      for (var channel in this.connector.channels) {
        this.leaveChannel(channel);
      }
    }
    /**
     * Listen for an event on a channel instance.
     */
  }, {
    key: "listen",
    value: function listen(channel, event, callback) {
      return this.connector.listen(channel, event, callback);
    }
    /**
     * Get a private channel instance by name.
     */
  }, {
    key: "private",
    value: function _private(channel) {
      return this.connector.privateChannel(channel);
    }
    /**
     * Get a private encrypted channel instance by name.
     */
  }, {
    key: "encryptedPrivate",
    value: function encryptedPrivate(channel) {
      return this.connector.encryptedPrivateChannel(channel);
    }
    /**
     * Get the Socket ID for the connection.
     */
  }, {
    key: "socketId",
    value: function socketId() {
      return this.connector.socketId();
    }
    /**
     * Register 3rd party request interceptiors. These are used to automatically
     * send a connections socket id to a Laravel app with a X-Socket-Id header.
     */
  }, {
    key: "registerInterceptors",
    value: function registerInterceptors() {
      if (typeof Vue === 'function' && Vue.http) {
        this.registerVueRequestInterceptor();
      }
      if (typeof axios === 'function') {
        this.registerAxiosRequestInterceptor();
      }
      if (typeof jQuery === 'function') {
        this.registerjQueryAjaxSetup();
      }
      if ((typeof Turbo === "undefined" ? "undefined" : _typeof(Turbo)) === 'object') {
        this.registerTurboRequestInterceptor();
      }
    }
    /**
     * Register a Vue HTTP interceptor to add the X-Socket-ID header.
     */
  }, {
    key: "registerVueRequestInterceptor",
    value: function registerVueRequestInterceptor() {
      var _this = this;
      Vue.http.interceptors.push(function (request, next) {
        if (_this.socketId()) {
          request.headers.set('X-Socket-ID', _this.socketId());
        }
        next();
      });
    }
    /**
     * Register an Axios HTTP interceptor to add the X-Socket-ID header.
     */
  }, {
    key: "registerAxiosRequestInterceptor",
    value: function registerAxiosRequestInterceptor() {
      var _this2 = this;
      axios.interceptors.request.use(function (config) {
        if (_this2.socketId()) {
          config.headers['X-Socket-Id'] = _this2.socketId();
        }
        return config;
      });
    }
    /**
     * Register jQuery AjaxPrefilter to add the X-Socket-ID header.
     */
  }, {
    key: "registerjQueryAjaxSetup",
    value: function registerjQueryAjaxSetup() {
      var _this3 = this;
      if (typeof jQuery.ajax != 'undefined') {
        jQuery.ajaxPrefilter(function (options, originalOptions, xhr) {
          if (_this3.socketId()) {
            xhr.setRequestHeader('X-Socket-Id', _this3.socketId());
          }
        });
      }
    }
    /**
     * Register the Turbo Request interceptor to add the X-Socket-ID header.
     */
  }, {
    key: "registerTurboRequestInterceptor",
    value: function registerTurboRequestInterceptor() {
      var _this4 = this;
      document.addEventListener('turbo:before-fetch-request', function (event) {
        event.detail.fetchOptions.headers['X-Socket-Id'] = _this4.socketId();
      });
    }
  }]);
  return Echo;
}();

exports.Channel = Channel;
exports.Connector = Connector;
exports.EventFormatter = EventFormatter;
exports["default"] = Echo;
